# 1.接口

## 1.接口入门 (接上文)

## 2.接口的成员特点

##### 1.成员变量

​	接口中的成员变量全部都是公共的静态常量!

​	默认使用public static final修饰的.缺哪个,JVM自动补哪个!

##### 2.成员方法

​	接口中的成员方法都是抽象方法(主流)   ---- JDK8以前
​        默认都是使用public abstract修饰的.缺哪个,JVM自动补哪个!

##### 3.构造方法

​	接口中没有构造!!!
​	注意:jdk8开始,接口中引入了一些新特性:默认方法,静态方法,私有方法

## 3.接口的新特性

##### 1.默认方法(Java 8)

​	使用default关键字修饰的方法,允许有方法体!
​        作用:保证了接口的功能平稳升级,不会对实现类产生影响.

##### 2.静态方法(Java 8)

​	使用static关键字修饰的方法,允许有方法体!
​        作用:保证了接口的功能平稳升级,不会对实现类产生影响.
​                 让方法的调用更加直接

##### 3.私有方法(Java 9)

​	使用private关键字修饰的方法,允许有方法体!
​        作用:将多个默认方法/静态方法中的共性内容进行抽取,提高代码复用性!

## 4.类和接口的关系

##### 1.类和类的关系

​		单继承,多层继承

##### 2.类与接口的关系

​		多实现关系!(一个类可以实现多个接口.使用implements后跟接口名用,隔开)

##### 3.接口和接口的关系

​		多继承!(一个接口可以继承多个接口)

## 5.接口和抽象类的区别

##### 1.语法区别

​		成员变量:
​                    抽象类可以定义基本的成员变量,也可以定义静态常量;
​                    接口中只能定义静态常量;
​                成员方法:
​                    抽象类中既可以定义基本的成员方法,也可以定义抽象方法;
​                    接口中用的都是抽象方法,新特性提供了(默认方法 静态方法 私有方法)
​                构造方法:
​                    抽象类有构造,因为是作为父类设计;
​                    接口没有构造,因为接口作为行为规范设计;

##### 2.设计区别

​                接口作为行为规范设计,对类的后天行为进行补充描述,进行规则的定义
​                接口和类的关系:多实现关系(一个类可以实现多个接口)
​                接口和接口的关系:多继承(一个接口可以继承多个接口)

​                抽象类作为父类设计,将多个子类中的共性内容提取到父类中,为了提高代码复用性.
​                类和类的关系:单继承关系(1个类只能继承1个类)



# 2.多态

## 1.面向对象三大特征

封装:面向对象的三大特征之一,使用类来封装数据(成员变量是用来封装数据的,成员方法是用来封装代码的) ---提高程序复用性
继承:面向对象的三大特征之一,使类与类之间产生子父类关系,子类加成父类,就可以直接使用父类的非私有成员 ---提高程序复用性
多态:面向对象的三大特征之一,描述事物的多种形态的一种语法.---提高程序拓展性.

## 2.多态的前提

​            1.把必须要有继承/实现关系
​            2.要有方法重写
​            3.父类引用指向子类对象/接口引用指向实现类对象.

```java
public class Demo {
    public static void main(String[] args) {
        Fu a = new Zi();
    }
}
```

## 3.多态的三种形式

#### 3.1普通类多态

​		就是指父类型是一个普普通通的类
​              	注意:如果普通类多态的话,方法重写为非必要条件

#### 3.2抽象类多态

​		指的是父类类型是一个抽象类

#### 3.3接口多态

​		指的就是等号左边是一个接口类型

## 4.多态语法下的成员特点

#### 4.1成员变量

​		编译看左边(父类),运行看左边(父类)

#### 4.2成员方法

​		编辑看左边(父类),运行看右边(子类)

## 5.多态的好处和弊端

#### 5.1好处

​	将方法的参数类型设计为父类形,未来调用方法时可以传递任	意子类对象,从而提高方法的灵活性\扩展性\拓展性.
​        (方法的参数是父类型时,方法可以接受任意子类型.)
​        (方法的返回值类型是父类型时,方法可以返回任意子类型.)

#### 5.2弊端

​        由于编译看左的语法限制,导致多态语法下不能访问子类的特有成员
​        解决方案:基于多态语法的向下转型解决.

## 6.多态的转型

​        1.向上转型 (隐式转换/自动类型转换)
​        2.向下转型 (强制类型转换)
​        注意:向下转型通常会伴随:ClassCastException(类型转换异常),为了使代码更加健壮, 推荐在强转之前使用instanceof 判断传递的真实对象类型,来判断规避问题

```java
public class Demo {
    public static void main(String[] args) {
        Swinmming s = new Dog(); //向上转型
        s.swim();
        Dog d = (Dog) s; //向下转型
        d.eat();
        useAnimal(new Dog());
        useAnimal(new Cat());
    }
  
    //当方法的参数类型是一个接口类型时,调用方法时只能传递该接口的实现类对象
    public static void useAnimal(Swinmming s) {
        //判断s记录的对象真实类型是否是Dog类型,是的话instanceof会返回true,否则false
        if (s instanceof Dog) {
            Dog d = (Dog) s;
            d.eat();
        }
    }
}
```

# 3.内部类(了解)

## 1.1 内部类的基本使用

- 内部类概念

  - 在一个类中定义一个类。

- 内部类定义格式

  - 格式&举例：

    ```java
    class Outer {
        public class Inner {
        }
    }
    ```

- 内部类的访问特点 

  - 内部类可以直接访问外部类的成员，包括私有
  - 外部类要访问内部类的成员，必须创建对象

## 1.2 成员内部类

- 成员内部类的定义位置
  - 在类中方法，跟成员变量是一个位置
- 外界创建成员内部类格式
  - 格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;
- 私有成员内部类
  - 将一个类，设计为内部类的目的，大多数都是不想让外界去访问，所以内部类的定义应该私有化，私有化之后，再提供一个可以让外界调用的方法，方法内部创建内部类对象并调用。
- 静态成员内部类
  - 静态成员内部类访问格式：外部类名.内部类名 对象名 = new 外部类名.内部类名();
  - 静态成员内部类中的静态方法：外部类名.内部类名.方法名();