# 1. java基础语法

## 1 Java概述

### 1.1 Java语言发展史

语言：人与人交流沟通的表达方式

计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言

Java语言是美国Sun公司在1995年推出的计算机语言

Java之父：詹姆斯·高斯林（James Gosling）

2009年，Sun公司被甲骨文公司收购，所以我们现在访问oracle官网即可：[https://www.oracle.com](https://www.oracle.com/) 

2022年，Xsh整理了此笔记

### 1.2 Java语言跨平台原理

Java程序并非是直接运行的，Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，然后由Java虚拟机（JVM）对字节码文件解释执行。所以在不同的操作系统下，只需安装不同的Java虚拟机即可实现java程序的跨平台。

### 1.3 JRE和JDK

JVM（Java Virtual Machine），Java虚拟机

JRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）

JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具

#### 1.4 JDK的安装目录介绍

| 目录名称    | 说明                                   |
| ------- | ------------------------------------ |
| bin     | 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 |
| conf    | 该路径下存放了JDK的相关配置文件。                   |
| include | 该路径下存放了一些平台特定的头文件。                   |
| jmods   | 该路径下存放了JDK的各种模块。                     |
| legal   | 该路径下存放了JDK各模块的授权文档。                  |
| lib     | 该路径下存放了JDK工具的一些补充JAR包。               |

## 2. 常用DOS命令

1、打开命令行窗口的方式：win + r打开运行窗口，输入cmd，回车。

2、常用命令及其作用

| 操作             | 说明                       |
| -------------- | ------------------------ |
| 盘符名称:          | 盘符切换。E:回车，表示切换到E盘。       |
| dir            | 查看当前路径下的内容。              |
| cd 目录          | 进入单级目录。cd itheima        |
| cd ..          | 回退到上一级目录。                |
| cd 目录1\目录2\... | 进入多级目录。cd itheima\JavaSE |
| cd \           | 回退到盘符目录。                 |
| cls            | 清屏。                      |
| exit           | 退出命令提示符窗口。               |

## 3. java基础语法

#### 3.1 注释（理解）

注释是对代码的解释和说明文字，可以提高程序的可读性，因此在程序中添加必要的注释文字十分重要。

单行注释: 

```java
// 这是单行注释文字
```

多行注释:

```java
/*
这是多行注释文字
*/
注意：多行注释不能嵌套使用。
```

文档注释:

```java
/**
这是文档注释文字
*/
```

#### 3.2 关键字（理解）

关键字是指被java语言赋予了特殊含义的单词。

关键字的特点：

​	关键字的字母全部小写。

​	常用的代码编辑器对关键字都有高亮显示。

#### 3.3 常量（应用）

常量：在程序运行过程中，其值不可以发生改变的量。

Java中的常量分类：

​	字符串常量  用双引号括起来的多个字符（可以包含0个、一个或多个）

​	整数常量  整数，例如：-10、0、88等

​	小数常量  小数，例如：-5.5、1.0、88.88等

​	字符常量  用单引号括起来的一个字符，例如：'a'、'5'、'B'、'中'等

​	布尔常量  布尔值，表示真假，只有两个值true和false

​	空常量  一个特殊的值，空值，值为null

除空常量外，其他常量均可使用输出语句直接输出。

#### 3.4 数据类型

##### 3.4.1 计算机存储单元

我们知道计算机是可以用来存储数据的，但是无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母”b”表示。而计算机中最基本的存储单元叫“字节（byte）”，

通常用大写字母”B”表示，字节是由连续的8个位组成。

除了字节外还有一些常用的存储单位，其换算单位如下：

1B（字节） = 8bit

1KB = 1024B

1MB = 1024KB

1GB = 1024MB

1TB = 1024GB

##### 3.4.2 Java中的数据类型

Java是一个强类型语言，Java中的数据必须明确数据类型。

在Java中的数据类型包括基本数据类型和引用数据类型两种。

Java中的基本数据类型：

| 数据类型 |   关键字   | 内存占用 |               取值范围                |
| :--: | :-----: | :--: | :-------------------------------: |
|  整数  |  byte   |  1   |    负的2的7次方 ~ 2的7次方-1(-128~127)    |
|      |  short  |  2   | 负的2的15次方 ~ 2的15次方-1(-32768~32767) |
|      |   int   |  4   |        负的2的31次方 ~ 2的31次方-1        |
|      |  long   |  8   |        负的2的63次方 ~ 2的63次方-1        |
| 浮点数  |  float  |  4   |   ±1.401298e-45 ~ 3.402823e+38    |
|      | double  |  8   |  ±4.9000000e-324 ~ 1.797693e+308  |
|  字符  |  char   |  2   |              0-65535              |
|  布尔  | boolean |  1   |            true，false             |

说明：

​	e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。

​	在java中整数默认是int类型，浮点数默认是double类型。

#### 3.5 变量

##### 3.5.1 变量的定义

变量：在程序运行过程中，其值可以发生改变的量。

从本质上讲，变量是内存中的一小块区域，其值可以在一定范围内变化。

变量的定义格式：

```java
// 声明变量并赋值
数据类型 变量名 = 初始化值; 
int age = 18;
```

或者

```java
// 先声明，后赋值（使用前赋值即可）
数据类型 变量名;
变量名 = 初始化值;
double money;
money = 55.5;
```

还可以在同一行定义多个同一种数据类型的变量，中间使用逗号隔开。

```java
int a = 10, b = 20; // 定义int类型的变量a和b，中间使用逗号隔开
int c,d; // 声明int类型的变量c和d，中间使用逗号隔开
c = 30;
d = 40;
```

##### 3.5.2 使用变量时的注意事项

1. 在同一对花括号中，变量名不能重复。
2. 变量在使用之前，必须初始化（赋值）。
3. 定义long类型的变量时，需要在整数的后面加L（大小写均可，建议大写）。因为整数默认是int类型，整数太大可能超出int范围。
4. 定义float类型的变量时，需要在小数的后面加F（大小写均可，建议大写）。因为浮点数的默认类型是double， double的取值范围是大于float的，类型不兼容。

#### 3.6 标识符

标识符是用户编程时使用的名字，用于给类、方法、变量、常量等命名。

Java中标识符的组成规则：

​	由字母、数字、下划线“_”、美元符号“$”组成，第一个字符不能是数字。

​	不能使用java中的关键字作为标识符。	

​	标识符对大小写敏感（区分大小写）。

Java中标识符的命名约定：

​	小驼峰式命名：变量名、方法名

​		首字母小写，从第二个单词开始每个单词的首字母大写。

​	大驼峰式命名：类名

​		每个单词的首字母都大写。

​	另外，标识符的命名最好可以做到见名知意

​		例如：username、studentNumber等。

#### 3.7 类型转换

在Java中，一些数据类型之间是可以相互转换的。分为两种情况：自动类型转换和强制类型转换。

**自动类型转换（隐式转换）：**  小类型数据转大类型

​	把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。这种转换方式是自动的，直接书写即可。例如：

```java
double num = 10; // 将int类型的10直接赋值给double类型
System.out.println(num); // 输出10.0
```

byte short char 在运算的时候会自动转换为int类型。

**强制类型转换：** 大类型转小类型

​	把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量。

​	强制类型转换格式：`目标数据类型 变量名 = (目标数据类型)值或者变量;`

```java
double num1 = 5.5;
int num2 = (int) num1; // 将double类型的num1强制转换为int类型
System.out.println(num2); // 输出5（小数位直接舍弃）
```

说明：

1. char类型的数据转换为int类型是按照码表中对应的int值进行计算的。比如在ASCII码表中，'a'对应97。

```java
int a = 'a';
System.out.println(a); // 将输出97
```

1. 整数默认是int类型，**byte、short和char类型数据参与运算均会自动转换为int类型**。

```java
byte b1 = 10;
byte b2 = 20;
byte b3 = b1 + b2; 
// 第三行代码会报错，b1和b2会自动转换为int类型，计算结果为int，int赋值给byte需要强制类型转换。
// 修改为:
int num = b1 + b2;
// 或者：
byte b3 = (byte) (b1 + b2);
```

1. boolean类型不能与其他基本数据类型相互转换。

## 4. 运算符

### 4.1 算术运算符（理解）

#### 4.1.1 运算符和表达式

运算符：对常量或者变量进行操作的符号

表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。

​                    不同运算符连接的表达式体现的是不同类型的表达式。

  +：是运算符，并且是算术运算符。

  a + b：是表达式，由于+是算术运算符，所以这个表达式叫算术表达式。

#### 4.1.2 算术运算符

| 符号   | 作用   | 说明             |
| ---- | ---- | -------------- |
| +    | 加    | 参看小学一年级        |
| -    | 减    | 参看小学一年级        |
| *    | 乘    | 参看小学二年级，与“×”相同 |
| /    | 除    | 参看小学二年级，与“÷”相同 |
| %    | 取余   | 获取的是两个数据做除法的余数 |

注意：

/和%的区别：两个数据做除法，/取结果的商，%取结果的余数。

整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。

#### 4.1.3 字符的“+”操作

char类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值：

'a'  --  97		a-z是连续的，所以'b'对应的数值是98，'c'是99，依次递加

'A'  --  65		A-Z是连续的，所以'B'对应的数值是66，'C'是67，依次递加

'0'  --  48		0-9是连续的，所以'1'对应的数值是49，'2'是50，依次递加

```java
// 可以通过使用字符与整数做算术运算，得出字符对应的数值是多少
char ch1 = 'a';
System.out.println(ch1 + 1); // 输出98，97 + 1 = 98
```

算术表达式中包含不同的基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。

提升规则：

byte类型，short类型和char类型将被提升到int类型，不管是否有其他类型参与运算。

整个表达式的类型自动提升到与表达式中最高等级的操作数相同的类型

​       等级顺序：byte,short,char --> int --> long --> float --> double

例如：

```java
byte b1 = 10;
byte b2 = 20;
// byte b3 = b1 + b2; // 该行报错，因为byte类型参与算术运算会自动提示为int，int赋值给byte可能损失精度
int i3 = b1 + b2; // 应该使用int接收
byte b3 = (byte) (b1 + b2); // 或者将结果强制转换为byte类型
-------------------------------
int num1 = 10;
double num2 = 20.0;
double num3 = num1 + num2; // 使用double接收，因为num1会自动提升为double类型
```

tips：正是由于上述原因，所以在程序开发中我们很少使用byte或者short类型定义整数。也很少会使用char类型定义字符，而使用字符串类型，更不会使用char类型做算术运算。

#### 4.1.4 字符串的“+”操作

当"+”操作中出现字符串时，这个”+”是字符串连接符，而不是算术运算。

```java
System.out.println("itheima"+ 666); // 输出：itheima666
```

在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行“+”操作时，从左到右逐个执行。

```java
System.out.println(1 + 99 + "年黑马"); // 输出：100年黑马
System.out.println(1 + 2 + "itheima" + 3 + 4); // 输出：3itheima34
// 可以使用小括号改变运算的优先级 
System.out.println(1 + 2 + "itheima" + (3 + 4)); // 输出：3itheima7
```

### 4.2 赋值运算符（应用）

赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。

| 符号   | 作用    | 说明             |
| ---- | ----- | -------------- |
| =    | 赋值    | a=10，将10赋值给变量a |
| +=   | 加后赋值  | a+=b，将a+b的值给a  |
| -=   | 减后赋值  | a-=b，将a-b的值给a  |
| *=   | 乘后赋值  | a*=b，将a×b的值给a  |
| /=   | 除后赋值  | a/=b，将a÷b的商给a  |
| %=   | 取余后赋值 | a%=b，将a÷b的余数给a |

注意：

**扩展的赋值运算符隐含了强制类型转换。**

```java
short s = 10;
s = s + 10; // 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度
s += 10; // 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10);
```

### 4.3 自增自减运算符（理解）

| 符号   | 作用   | 说明     |
| ---- | ---- | ------ |
| ++   | 自增   | 变量的值加1 |
| --   | 自减   | 变量的值减1 |

注意事项：

​	++和-- 既可以放在变量的后边，也可以放在变量的前边。

​	单独使用的时候， ++和-- 无论是放在变量的前边还是后边，结果是一样的。

```
参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做++或者--。
参与操作的时候，如果放在变量的前边，先拿变量做++或者--，后拿变量参与操作。

口诀：
符号在变量前：先运算，后使用     （先让变量+1、-1，再使用变量的值）
符号在变量后：先使用，后运算		（先使用变量的值，后让变量+1、-1）
```

### 4.4 关系运算符（应用）

关系运算符有6种关系，分别为小于、小于等于、大于、等于、大于等于、不等于。

| 符号   | 说明                                  |
| ---- | ----------------------------------- |
| ==   | a==b，判断a和b的值是否相等，成立为true，不成立为false  |
| !=   | a!=b，判断a和b的值是否不相等，成立为true，不成立为false |
| >    | a>b，判断a是否大于b，成立为true，不成立为false      |
| >=   | a>=b，判断a是否大于等于b，成立为true，不成立为false   |
| <    | a<b，判断a是否小于b，成立为true，不成立为false      |
| <=   | a<=b，判断a是否小于等于b，成立为true，不成立为false   |

注意事项：

​	关系运算符的结果都是boolean类型，要么是true，要么是false。

​	千万不要把“==”误写成“=”，"=="是判断是否相等的关系，"="是赋值。

### 4.5 逻辑运算符（应用）

逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。

| 符号   | 作用   | 说明                               |
| ---- | ---- | -------------------------------- |
| &    | 逻辑与  | a&b，a和b都是true，结果为true，否则为false   |
| \|   | 逻辑或  | a\|b，a和b都是false，结果为false，否则为true |
| ^    | 逻辑异或 | a^b，a和b结果不同为true，相同为false        |
| !    | 逻辑非  | !a，结果和a的结果正好相反                   |

#### 短路逻辑运算符

| 符号   | 作用   | 说明              |
| ---- | ---- | --------------- |
| &&   | 短路与  | 作用和&相同，但是有短路效果  |
| \|\| | 短路或  | 作用和\|相同，但是有短路效果 |

在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，短路与操作就有这样的效果，可以提高效率。同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算。

- 逻辑与&，无论左边真假，右边都要执行。
- 短路与&&，如果左边为真，右边执行；如果左边为假，右边不执行。
- 逻辑或|，无论左边真假，右边都要执行。
- 短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。

### 4.6 三元运算符（理解）

三元运算符语法格式：

```java
关系表达式 ? 表达式1 : 表达式2;
```

解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。

举例：

```java
int a = 10;
int b = 20;
int c = a > b ? a : b; // 判断 a>b 是否为真，如果为真取a的值，如果为假，取b的值
```



# 2.流程控制语句

在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。

## 1. 流程控制语句分类

​	顺序结构

​	分支结构(if, switch)

​	循环结构(for, while, do…while)

## 2. 顺序结构

顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。

## 3. 分支结构

#### 3.1 if语句

##### 3.1.1 if语句格式1

```java
格式：
if (关系表达式) {
    语句体;	
}
```

##### 3.1.2 if语句格式2

```java
格式：
if (关系表达式) {
    语句体1;	
} else {
    语句体2;	
}
```

##### if语句格式3

```java
格式：
if (关系表达式1) {
    语句体1;	
} else if (关系表达式2) {
    语句体2;	
} 
…
else {
    语句体n+1;
}
```

执行流程：

①首先计算关系表达式1的值

②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值

③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值

④如果没有任何关系表达式为true，就执行语句体n+1。

#### 3.2 switch语句

格式

```java
switch (表达式) {
	case 1:
		语句体1;
		break;//中断
	case 2:
		语句体2;
		break;
	...
	default:
		语句体n+1;
		break;
}
```

- 执行流程：
  - 首先计算出表达式的值 
  - 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。 
  - 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 


- 注意：如果switch中得case，没有对应break的话，则会出现case穿透的现象。

#### 3.3 for循环

- 循环：

  循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形 成死循环。 

- for循环格式：

```java
for (初始化语句;条件判断语句;条件控制语句) {
	循环体语句;
}
```

- 格式解释：

  - 初始化语句：  用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样
  - 条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去
  - 循环体语句：  用于表示循环反复执行的内容，简单说就是循环反复执行的事情
  - 条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去

- 执行流程：

  ①执行初始化语句

  ②执行条件判断语句，看其结果是true还是false

  ​             如果是false，循环结束

  ​             如果是true，继续执行

  ③执行循环体语句

  ④执行条件控制语句

  ⑤回到②继续

#### 3.4 while循环

- while循环完整格式：

  ```java
  初始化语句;
  while (条件判断语句) {
  	循环体语句;
      条件控制语句;
  }
  ```

- while循环执行流程：

  ①执行初始化语句

  ②执行条件判断语句，看其结果是true还是false

  ​             如果是false，循环结束

  ​             如果是true，继续执行

  ③执行循环体语句

  ④执行条件控制语句

  ⑤回到②继续

#### 3.5 do...while循环结构（掌握）

- 完整格式：

  ```java
  初始化语句;
  do {
      
  	循环体语句;
  	条件控制语句;
      
  }while(条件判断语句);
  ```

- 执行流程：

  ① 执行初始化语句

  ② 执行循环体语句

  ③ 执行条件控制语句

  ④ 执行条件判断语句，看其结果是true还是false

  如果是false，循环结束

  如果是true，继续执行

  ⑤ 回到②继续

#### 3.6 三种循环的区别

- 三种循环的区别
  - for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行）
  - do...while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断）
- for循环和while的区别
  - 条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了
  - 条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用

使用建议：

指定次数的循环用for

不确定次数的循环用while

至少要执行一次的循环，用do...while

#### 3.7 死循环

1. for(;;){}
2. **while(true){}**
3. do {} while(true);

#### 3.8 跳转控制语句

- 跳转控制语句（break）
  - 跳出循环，结束循环
- 跳转控制语句（continue）
  - 跳过本次循环，继续下次循环
- 注意： continue只能在循环中进行使用！

#### 4.4 循环嵌套

- 循环嵌套概述：在循环中，继续定义循环
- 理解：
  - 请反复理解这句话（整个内循环，就是外循环的一个循环体，内部循环体没有执行完毕，外循环是不会继续向下执行的）
- 结论：
  - 外循环执行一次，内循环执行一圈



# 3.数组

## 1.什么是数组

​	数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致。 

## 2.数组定义格式

​	1.数据类型[] 数组名

```java
int[] arr;        
double[] arr;      
char[] arr;
```

​	2.数据类型 数组名[]

```java
int arr[];
double arr[];
char arr[];
```

## 3.数组动态初始化

数组动态初始化就是只给定数组的长度，由系统给出默认初始化值

```java
数据类型[] 数组名 = new 数据类型[数组长度];
int[] arr = new int[3];
```

## 4.静态初始化

在创建数组时，直接将元素确定	

```java
//完整版格式
数据类型[] 数组名 = new 数据类型[]{元素1,元素2,...};
//简化版格式
数据类型[] 数组名 = {元素1,元素2,...};
```

## 5.数组元素访问

#### 5.1什么是索引

​	每一个存储到数组的元素，都会自动的拥有一个编号，从0开始。

​	这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。 	

```java
数组名[索引];
```

#### 5.2内存概述

​	内存是计算机中的重要原件，临时存储区域，作用是运行程序。

​	我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的。

​	必须放进内存中才能运行，运行完毕后会清空内存。 

​	Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。 

#### 5.3java中的内存分配

​	目前我们只需要记住两个内存，分别是：栈内存和堆内存

| 区域名称  | 作用                              |
| ----- | ------------------------------- |
| 寄存器   | 给CPU使用，和我们开发无关。                 |
| 本地方法栈 | JVM在使用操作系统功能的时候使用，和我们开发无关。      |
| 方法区   | 存储可以运行的class文件。                 |
| 堆内存   | 存储对象或者数组，new来创建的，都存储在堆内存。       |
| 方法栈   | 方法运行时使用的内存，比如main方法运行，进入方法栈中执行。 |

## 6.索引越界与空指针

#### 6.1索引越界异常

```java
public class ArrayDemo {
    public static void main(String[] args) {
        int[] arr = new int[3];
        System.out.println(arr[3]);
    }
}
```

数组长度为3，索引范围是0~2，但是我们却访问了一个3的索引。

程序运行后，将会抛出ArrayIndexOutOfBoundsException 数组越界异常。

#### 6.2空指针异常

```java
public class ArrayDemo {
    public static void main(String[] args) {
        int[] arr = new int[3];
        //把null赋值给数组
        arr = null;
        System.out.println(arr[0]);
    }
}
```

arr = null 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。

## 7.数组遍历

- 数组遍历：就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。

- 如果数组元素非常多我们需要改造成循环的写法。

  ```java
  public class ArrayTest01 {
      public static void main(String[] args) {
          //定义数组
          int[] arr = {11, 22, 33, 44, 55};
          //使用通用的遍历格式
          for(int x=0; x<arr.length; x++) {
              System.out.println(arr[x]);
          }
      }
  }
  ```




# 4. 方法

## 1. 方法的概念

​	方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集

- 注意：
  - 方法必须先创建才可以使用，该过程成为方法定义
  - 方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程称为方法调用

## 2.方法的通用格式

- 格式：

  ```java
  public static 返回值类型 方法名(参数) {
     方法体; 
     return 数据 ;
  }
  ```

- 解释：

  - public static 	修饰符，目前先记住这个格式

    返回值类型	方法操作完毕之后返回的数据的数据类型

    ​			如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return

     方法名		调用方法时候使用的标识

     参数		由数据类型和变量名组成，多个参数之间用逗号隔开

     方法体		完成功能的代码块

     return		如果方法操作完毕，有数据返回，用于把数据返回给调用者

- 定义方法时，要做到两个明确

  - 明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型
  - 明确参数：主要是明确参数的类型和数量

- 调用方法时的注意：

  - void类型的方法，直接调用即可
  - 非void类型的方法，推荐用变量接收调用

### 2.1 无参数方法

- 定义格式：

  ```java
  public static void 方法名 () {
  	// 方法体;
  }
  ```

- 调用格式：

  ```java
  方法名();	
  ```

### 2.2 带参数方法

- 定义格式：

  参数：由数据类型和变量名组成 

  ```java
  public static void 方法名 (参数1) {
  	方法体;
  }

  public static void 方法名 (参数1, 参数2, 参数3...) {
  	方法体;
  }
  ```

  - 方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错

- 调用格式：

  ```java
  方法名(参数)；

  方法名(参数1,参数2);
  ```

  - 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错 

### 2.3带返回值方法

- 定义格式

  ```java
  public static 数据类型 方法名 ( 参数 ) { 
  	return 数据 ;
  }
  ```

  - 方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错

- 调用格式

  ```java
  方法名 ( 参数 ) ;
  数据类型 变量名 = 方法名 ( 参数 ) ;
  ```

  - 方法的返回值通常会使用变量接收，否则该返回值将无意义

### 2.4 形参和实参

1. 形参：方法定义中的参数

​          等同于变量定义格式，例如：int number

1. 实参：方法调用中的参数

​          等同于使用变量或常量，例如： 10  number

## 3. 注意事项

- 方法必须先定义，后调用，否则程序将报错
- 方法不能嵌套定义
- void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据

## 4. 方法重载

- 方法重载概念

  方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载

  - 多个方法在同一个类中
  - 多个方法具有相同的方法名
  - 多个方法的参数不相同，类型不同或者数量不同

- 注意：

  - 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式
  - 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载

  ```java
  public class MethodDemo {
  	public static void fn(int a) {
      	//方法体
      }
      public static int fn(double a) {
      	//方法体
      }
  }

  public class MethodDemo {
  	public static float fn(int a) {
      	//方法体
      }
      public static int fn(int a , int b) {
      	//方法体
      }
  }
  ```

## 5.方法的参数传递

### 5.1 参数传递基本类型

- 测试代码：

  ```java
  public class ArgsDemo01 {
      public static void main(String[] args) {
          int number = 100;
          System.out.println("调用change方法前：" + number);
          change(number);
          System.out.println("调用change方法后：" + number);
      }

      public static void change(int number) {
          number = 200;
      }
  }

  ```

- 结论：

  - 基本数据类型的参数，形式参数的改变，不影响实际参数 

- 结论依据：

  - 每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失

### 5.2 方法参数传递引用类型（理解）

- 测试代码：

  ```java
  public class ArgsDemo02 {
      public static void main(String[] args) {
          int[] arr = {10, 20, 30};
          System.out.println("调用change方法前：" + arr[1]);
          change(arr);
          System.out.println("调用change方法后：" + arr[1]);
      }

      public static void change(int[] arr) {
          arr[1] = 200;
      }
  }

  ```

- 结论：

  - 对于引用类型的参数，形式参数的改变，影响实际参数的值 

- 结论依据：

  - 引用数据类型的传参，传入的是地址值，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果 



# 5. 进制

## 1. 进制的介绍与书写格式

```java
public class Demo1 {
    /*
        十进制：Java中，数值默认都是10进制，不需要加任何修饰。
        二进制：数值前面以0b开头，b大小写都可以。
        八进制：数值前面以0开头。
        十六进制：数值前面以0x开头，x大小写都可以。
        注意: 书写的时候, 虽然加入了进制的标识, 但打印在控制台展示的都是十进制数据.
     */
    public static void main(String[] args) {
        System.out.println(10);
        System.out.println("二进制数据0b10的十进制表示为:" + 0b10);
        System.out.println("八进制数据010的十进制表示为:" + 010);
        System.out.println("十六进制数据0x10的十进制表示为:" + 0x10);
    }
}
```

## 2. 进制转换

#### 	 2.1十进制到二进制的转换

​	公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。

​	需求：将十进制数字11，转换为2进制。

​	实现方式：源数据为11，使用11不断的除以基数，也就是2，直到商为0。

#### 	2.2十进制到十六进制的转换

​	公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。

​	需求：将十进制数字60，转换为16进制。

​	实现方式：源数据为60，使用60不断的除以基数，也就是16，直到商为0。

​	结论：十进制到任意进制的转换

​	公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着	拼起来即可

## 3.快速进制转换法

​	8421码：

​	8421码又称BCD码，是BCD代码中最常用的一种BCD： (Binary-Coded Decimal‎) 二进制码十进制数在这种编码方式中，每一位二进制值的1都是代表一个固定数值，把每一位的1代表的十进制数加起来得到的结果就是它所代表的十进制数。

## 4.原码反码补码

前言 : 计算机中的数据，都是以二进制补码的形式在运算，而补码则是通过反码和原码推算出来的

**原码 **:（可直观看出数据大小）

就是二进制定点表示法，即最高位为符号位，【0】表示正，【1】表示负，其余位表示数值的大小。

通过一个字节表示+7和-7，代码：byte b1 = 7;   byte b2 = -7;一个字节等于8个比特位，也就是8个二进制位	

0(符号位)	0000111 	

1(符号位)	0000111

**反码 :** 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。

**补码 :** （数据以该状态进行运算）正数的补码与其原码相同；负数的补码是在其反码的末位加1。

## 5.位运算-基本位运算符

```java
public class Demo {
    /*
        位运算:
            位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。
            在二进制位运算中，1表示true，0表示false。
             & 位与 : 遇false则false, 遇0则0
                        00000000 00000000 00000000 00000110     // 6的二进制
                     &  00000000 00000000 00000000 00000010     // 2的二进制
                    -----------------------------------------
                        00000000 00000000 00000000 00000010     // 结果: 2
             | 位或 : 遇true则true, 遇1则1
             ^ 位异或 : 相同为false, 不同为true
             ~ 取反 : 全部取反, 0变1, 1变0  (也包括符号位)
                    00000000 00000000 00000000 00000110         // 6的二进制补码
                  ~ 11111111 11111111 11111111 11111001
                  -                                   1         // -1求反码
                   ------------------------------------
                    11111111 11111111 11111111 11111000         // 反码推原码
                    10000000 00000000 00000000 00000111         // -7
     */
    public static void main(String[] args) {
        System.out.println(6 & 2);
        System.out.println(~6);
    }
}
```

## 6. 位运算-位移运算符

**位运算概述 :**  位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。在二进制位运算中，1表示true，0表示false

**代码 :** 

```java
public class Demo3 {
    /*
       位移运算符:
               << 有符号左移运算，二进制位向左移动, 左边符号位丢弃, 右边补齐0
                        运算规律: 向左移动几位, 就是乘以2的几次幂
                                12 << 2
                                (0)0000000 00000000 00000000 000011000  // 12的二进制
      -----------------------------------------------------------------------------
               >> 有符号右移运算，二进制位向右移动, 使用符号位进行补位
                        运算规律: 向右移动几位, 就是除以2的几次幂
                                000000000 00000000 00000000 0000001(1)  // 3的二进制
       -----------------------------------------------------------------------------
                >>> 无符号右移运算符,  无论符号位是0还是1，都补0
                                010000000 00000000 00000000 00000110  // -6的二进制
     */
    public static void main(String[] args) {
        System.out.println(12 << 1);  // 24
        System.out.println(12 << 2);  // 48
    }
}
```

```java
public class Demo4 {
    /*
        ^ 运算符的特点
                一个数, 被另外一个数, 异或两次, 该数本身不变
     */
    public static void main(String[] args) {
        System.out.println(10 ^ 5 ^ 10);
    }
}
```



# 6. 类和对象

## 1.面向对象和面向过程

​	**面向过程 (Procedure Oriented)：**是一种以过程为中心的编程思想，实现功能的每一步，都是自己实现的.

​		就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。

​	**面向对象 (Object-Oriented)：**是一种以对象为中心的编程思想，通过指挥对象实现具体的功能.

​		是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。

## 2. 类和对象的关系

客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。

- 类
  - 类的理解
    - 类是对现实生活中一类具有共同属性和行为的事物的抽象
    - 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合
    - 简单理解：类就是对现实事物的一种描述
  - 类的组成
    - 属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）
    - 行为：指事物能执行的操作，例如：手机事物（打电话，发短信）
- 类和对象的关系
  - 类：类是对现实生活中一类具有共同属性和行为的事物的抽象

  - 对象：是能够看得到摸的着的真实存在的实体

  - 简单理解：**类是对事物的一种描述，对象则为具体存在的事物**

    ​	       	  **类是对象的模板,对象是类的实例**

## 3. 类的定义

### 3.1类的定义

类的组成是由属性和行为两部分组成

- **属性：**在类中通过成员变量来体现（类中方法外的变量）
- **行为：**在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）

**类的定义步骤：**

​	① 定义类

​	② 编写类的成员变量

​	③ 编写类的成员方法

```java
public class Student {
    // 属性 : 姓名, 年龄
    // 成员变量: 跟之前定义变量的格式一样, 只不过位置发生了改变, 类中方法外
    String name;
    int age;

    // 行为 : 学习
    // 成员方法: 跟之前定义方法的格式一样, 只不过去掉了static关键字.
    public void study(){
        System.out.println("学习");
    }
}
```

### 3.2对象的创建和使用

- **创建对象的格式：**
  - 类名 对象名 = new 类名();
- **调用成员的格式：**
  - 对象名.成员变量
  - 对象名.成员方法();
- 2. 对象内存图

### 3.3多个对象内存

多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份

### 3.4多个对象指向相同内存

当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的）

只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。

### 3.5 成员变量和局部变量

- **类中位置不同：**成员变量（类中方法外）局部变量（方法内部或方法声明上）
- **内存中位置不同：**成员变量（堆内存）局部变量（栈内存）
- **生命周期不同：**成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）
- **初始化值不同：**成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）

## 4. 封装

### 4.1 private关键字

​	**概述 :** private是一个修饰符，可以用来修饰成员（成员变量，成员方法）

​	**特点 :** 被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，	提供相应的操作

​		提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰

​		提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰

### 4.2 private关键字的使用

- **需求：**

  - 定义标准的学生类，要求name和age使用private修饰
  - 并提供set和get方法以及便于显示数据的show方法
  - 测试类中创建对象并使用，最终控制台输出  林青霞，30 


### 4.3 this关键字【应用】

**概述 :** this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）

- 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量
- 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量
- this代表当前调用方法的引用，哪个对象调用的方法，this就代表哪一个对象

**代码实现 :** 

```java
public class Student {
    private String name;

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

```

### 4.4 封装思想

1. **封装概述**
   是面向对象三大特征之一（封装，继承，多态）
   是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的
2. **封装原则**
   将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问
   成员变量private，提供对应的getXxx()/setXxx()方法
3. **封装好处**
   通过方法来控制成员变量的操作，提高了代码的安全性
   把代码用方法进行封装，提高了代码的复用性

## 5. 构造方法

### 5.1 构造方法的格式和执行时机

- **格式注意 :**
  - 方法名与类名相同，大小写也要一致
  - 没有返回值类型，连void都没有
  - 没有具体的返回值（不能由retrun带回结果数据）
- **执行时机 ：**
  - 创建对象的时候调用，每创建一次对象，就会执行一次构造方法
  - 不能手动调用构造方法

- **构造方法的作用**
  - 用于给对象的数据（属性）进行初始化

### 5.2 构造方法的注意事项

**构造方法的创建 :** 

​	如果没有定义构造方法，系统将给出一个默认的无参数构造方法

​	如果定义了构造方法，系统将不再提供默认的构造方法

**构造方法的创建 :** 

​	如果没有定义构造方法，系统将给出一个默认的无参数构造方法如果定义了构造方法，系统将不再提供默认的构造方法

**推荐的使用方式 :** 

​	无论是否使用，都手动书写无参数构造方法，和带参数构造方法



# 7.ArrayList

## 1.ArrayList类概述

- 什么是集合

  ​	提供一种存储空间可变的存储模型，存储的数据容量可以发生改变

- ArrayList集合的特点

  ​	底层是数组实现的，长度可以变化

- 泛型的使用

  ​	用于约束集合中存储元素的数据类型

## 2.ArrayList类常用方法

#### 2.1构造方法

| 方法名                | 说明         |
| ------------------ | ---------- |
| public ArrayList() | 创建一个空的集合对象 |

**ArrayList<E> ：** 

​	可调整大小的数组实现 

​	<E> : 是一种特殊的数据类型，泛型。

**怎么用呢 ?**	

​	在出现E的地方我们使用引用数据类型替换即可	

​	举例：ArrayList<String>, ArrayList<Student>

#### 2.2成员方法

| 方法名                                      | 说明                  |
| ---------------------------------------- | ------------------- |
| public boolean   remove(Object o)        | 删除指定的元素，返回删除是否成功    |
| public E   remove(int   index)           | 删除指定索引处的元素，返回被删除的元素 |
| public E   set(int index,E   element)    | 修改指定索引处的元素，返回被修改的元素 |
| public E   get(int   index)              | 返回指定索引处的元素          |
| public int   size()                      | 返回集合中的元素的个数         |
| public boolean   add(E e)                | 将指定的元素追加到此集合的末尾     |
| public void   add(int index,E   element) | 在此集合中的指定位置插入指定的元素   |

## 3.集合和数组的区别 :

​	共同点：都是存储数据的容器

​	不同点：数组的容量是固定的，集合的容量是可变的



# 常用API

### 1.API

- 什么是API

  ​	API (Application Programming Interface) ：应用程序编程接口

  ​	JDK提供的一些核心类


- java中的API

  ​	指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。

### 2.String

##### 2.1String类的特点

- 字符串不可变，它们的值在创建后不能被更改
- 虽然 String 的值是不可变的，但是它们可以被共享
- 字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )

##### 2.2String类的构造方法

| 方法名                         | 说明                     |
| --------------------------- | ---------------------- |
| public   String()           | 创建一个空白字符串对象，不含有任何内容    |
| public   String(char[] chs) | 根据字符数组的内容，来创建字符串对象     |
| public   String(byte[] bys) | 根据字节数组的内容，来创建字符串对象     |
| public  String(String str)  | 借助一个字符串构建一个新的字符串对象     |
| String s =   “abc”;         | 直接赋值的方式创建字符串对象，内容就是abc |

##### 2.3创建字符串对象

- 通过构造方法创建

  ​	通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同

- 直接赋值方式创建

  ​	以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护. 双引号定义在常量池，可以复用

##### 2.4字符串的比较

###### 2.4.1==号的作用

- 比较基本数据类型：比较的是具体的值
- 比较引用数据类型：比较的是对象地址值

```java
String a = "Hello";
String b = a+"World";
底层通过StringBuilder(StringBuffer) 使用 append方法进行拼接，最后使用toString方法进行转换。
```

###### 2.5.2equals方法的作用

- 方法介绍

  ```java
  public boolean equals(String s)     比较两个字符串内容是否相同、区分大小写
  public boolean equalsIgnorCase(String s) 忽略大小写进行比较
  ```

##### 2.5String常用方法

```java
//创建一个空白字符串对象,不包含任何内容
string s=new String();
//根据字符数组的内容,来创建字符串对象
char[] arr={a,b.c...};
string s=new String(arr);
//根据传入的字符串内容,来创建字符串对象
string s=new String("abc");
//直接赋值的方式创建字符串对象
String s="abc";

//比较字符串内容, 区分大小写,返回boolean值
s1.equals(s2);
//比较字符串内容, 忽略大小写,返回boolean值
s1.equalsIgnoreCase(s2);
//获取字符串长度
s.length();
//返回指定索引处的char值 
char c = s.charAt(i);
//将当前字符串拆分为字符数组并返回
char[] arr = s.toCharArray();
//截取字符串并返回
String s2 = s1.substring(0,3); //索引0到索引2的内容
String s2 = s1.substring(7); //索引7到结尾的内容
//将当前字符串中的target内容，使用replacement进行替换，返回新的字符串
String s2 = s1.replace("TMD","***");
//根据regex内容切割字符串，得到字符串数组
String[] arr = s.split(",");
//将当前字符串字母全部转为小写
s=s.toLowerCase();
//将当前字符串字母全部转为大写
s=s.toUpperCase();
//消除当前字符串的首尾的空格
s=s.trim();
//判断当前字符串是否包含指定的内容,包含返回true,不包含就返回false
boolean b=s.contains(" ");
//判断当前字符串是否以指定内容开头
boolean b=s.startsWith(" ");
//判断当前字符串是否以指定内容结尾
boolean b=s.endsWith(" ");
//获取指定内容在当前字符串中第一次出现的索引位置
int index=s.indexOf(" ");

//String转化为int
int a=Integer.parseInt(str);
```

### 3.StringBuilder

#### 3.1StringBuilder类概述

​	StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的

#### 3.2StringBuilder类和String类的区别

- String类：内容是不可变的
- StringBuilder类：内容是可变的

#### 3.3StringBuilder类的构造方法

- 常用的构造方法

  | 方法名                                | 说明                    |
  | ---------------------------------- | --------------------- |
  | public StringBuilder()             | 创建一个空白可变字符串对象，不含有任何内容 |
  | public StringBuilder(String   str) | 根据字符串的内容，来创建可变字符串对象   |

#### 3.4StringBuilder常用方法

| 方法名                                  | 说明                                       |
| ------------------------------------ | ---------------------------------------- |
| public   StringBuilder append (任意类型) | 添加数据，并返回对象本身                             |
| public   StringBuilder reverse()     | 返回相反的字符序列                                |
| public   int   length()              | 返回长度，实际存储值                               |
| public   String toString()           | 通过toString()就可以实现把StringBuilder转换为String |

```java
//创建一个空白可变字符串对象，不含有任何内容
StringBuilder sb = new StringBuilder();
//根据字符串的内容，来创建可变字符串对象
StringBuilder sb = new StringBuilder("hello");
//添加数据，并返回对象本身
sb.append("abc");
//返回相反的字符序列(反转)
sb.reverse();
//StringBuilder 转换为 String
String s = sb.toString();
//String 转换为 StringBuilder
StringBuilder sb = new StringBuilder(s);
```

### 4.Scanner

1、导包。Scanner 类在java.util包下，所以需要将该类导入。导包的语句需要定义在类的上面。

```java
import java.util.Scanner; 
```

2、创建Scanner对象。

```java
Scanner sc = new Scanner(System.in);// 创建Scanner对象，sc表示变量名，其他均不可变
```

3、接收数据

```java
int i = sc.nextInt(); // 表示将键盘录入的值作为int数返回。
```

示例：

```java
import java.util.Scanner;
public class ScannerDemo {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);//创建对象
		int x = sc.nextInt();//接收数据
		System.out.println("x:" + x);//输出数据
	}
}
```

### 5.Random

- 概述：

  - Random类似Scanner，也是Java提供好的API，内部提供了产生随机数的功能

- 使用步骤：

  1. 导入包

     import java.util.Random;

  2. 创建对象

     Random r = new Random();

  3. 产生随机数

     int num = r.nextInt(10);

     解释： 10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0-19

- 示例代码：

```java
import java.util.Random;
public class RandomDemo {
	public static void main(String[] args) {
		Random r = new Random();//创建对象
		for(int i=0; i<10; i++) {
			int number = r.nextInt(10);//获取随机数 0-9
		}
		int x = r.nextInt(100) + 1;//获取随机数1-100
	}
}
```

### 6.equals

```java
stu1.equals(stu2)
stu1.equalsIgnoreCase(stu2)
```

​	重写前:在Object中默认逻辑是比较双方地址值.
​	重写后:是比较双方属性值

### 7.toString

​	重写前:在Object中返回对象的地址值;
​	重写后:返回值是属性值!

### 8.System

```java
	//获得当前时间获得的毫秒值
System.currentTimeMillis()
	//结束当前java虚拟机
System.exit(0)
```

